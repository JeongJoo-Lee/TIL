# 프로세스와 스레드
## 프로세스
* 정의 : 메모리에 올라와 리소스를 할당받아 실행하는 프로그램
* 특징
  * 다른 프로세스의 자원에 독립된 메모리 영역을 할당 받음
  * 프로세스는 최소 1개의 메인 스레드를 가짐
* 추상화(비유)</br>
  ![image](https://user-images.githubusercontent.com/61656046/126171025-576c538b-f380-4d2f-bfb4-797e48ac8b19.png)
  ```
  땅(OS)에 있는 리소스(미네랄)를 해야할 작업(프로세스)에 할당하면 그 작업이 실행되는 것(스레드)을 볼 수 있다.
  
  위 예시 그림은 프로브 한개가 생성되고있는 프로세스가 실행중인 것이다.
  ```
  
## 스레드
* 정의 : 프로세스에 할당된 자원을 이용해 동작하는 실행 단위

* 특징 :
  - 프로세스 Stack만 따로 할당 받고(stack 에 저장된 함수 호출 정보 때문에 공유되면 복잡해짐), Code, Data, Heap영역은 공유한다.
  - 하나의 프로세스 내에서 여러 스레드가 있다면 서로 스레드의 결과를 즉시 확인할 수 있다.
* 추상화(비유)</br>
![image](https://user-images.githubusercontent.com/61656046/126174942-11d02a71-08db-4e66-9026-ca7e7f7ca628.png)
```
예를 들어 우리는 지금 마린을 100기 뽑아야 한다면 [마린의 생성] 이라는 프로그램, 
즉 프로세스를 통해 마린 생성에 들어가는 미네랄(자원) 을 소모해 최종적으로 프로세스가
원하는 작업을 처리하는 것이 [스레드] 이다.

+ 마린 100마리를 하나의 배럭에 생산을 하면 비 효율적이기 때문에 
많은 배럭을 설치해 마린을 동시 다발적으로 생산하는 것이 멀티 스레드로 알려져있다.
```

# 멀티 프로세스 & 멀티 스레드
## 멀티 프로세스
* 멀티 프로세스
  - 정의 : 하나의 프로그램을 여러 개의 프로세스로 구성한 것.
  - 특징
```
1개의 프로세스가 죽어도 자식 프로세스 이외의 프로세스는 계속 실행 됨.
Context Switching 을 위한 오버헤드(캐시 초기화, 인터럽트)가 자주 발생
프로세스 자체가 독립적인 메모리를 할당 받기 때문에 통신이 어려움.
```
## 멀티 스레드
- 정의 : 하나의 프로세스의 작업을 병렬 처리로 진행하는 것
- 특징
```
프로세스의 자원 할당을 위한 시스템콜 , Context Switching의 오버헤드가 줄어듦.
통신이 쉽고 자원을 효율적으로 사용 가능.
하나의 스레드에 문제가 생기면 전체 프로세스가 영향 받음.
공유 자원(동기화)의 문제가 발생할 수 있음
```

# 장기 스케줄러 & 단기 스케줄러
## 장기 스케줄러
* 메모리와 디스크 사이의 스케줄 담당.
* 어떤 프로세스에 각종 리소스를 할당할지를 결정
* 실행 중인 프로세스의 수 제어
* new 👉 ready

## 단기 스케줄러
* CPU와 메모리 사이의 스케줄을 담당
* Ready Q에 있는 프로세스 중 어떤 프로세스를 Running 시킬지 결정
* 프로세스에 CPU 할당 (dispatch)
* ready 👉 running 👉 waiting 👉 ready

## 중기 스케줄러
* 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄 (swapping)
* 메모리를 deallocate
* 실행 중인 프로세스의 수 제어
* 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절.
* ready 👉 suspended

# 세마포어 & 뮤텍스
## 뮤텍스 
Locking 메커니즘으로 Lock을 걸은 스레드만 임계 영역을 나갈 때 Lock 해제.
## 세라포머
Signaling 메커니즘으로 Lock을 걸지 않은 스레드도 signal을 사용해 Lock을 해제 가능. (세라포머의 카운터를 1로하면 뮤텍스처럼 활용 가능)

## 임계영역
동일한 자원을 동시에 접근하는 작업의 코드 영역.

## Lock
동시에 공유 자원에 접근하는 것을 막기 위해 임계영역에 진입하는 프로세스는 lock을 획득하고 빠져나올 때 lock을 방출 함으로써 동시 접근을 막음. but 시간적인 효율성 측면에서는 좋지 않음

