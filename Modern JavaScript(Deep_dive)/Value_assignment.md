# 📎 값의 할당(assignment)과 재할당
<br>

## 값의 할당
* 변수에 값을 할당(assignment) 할 때는 할당 연산자 = 을 사용한다. 할당 연산자는 우변의 값을 좌변의 변수에 저장한다.
```javascript
var score;      // 변수 선언

score = 80;     // 값의 할당

var score = 80  // 변수 선언과 값의 할당(한줄표현)
```
> 변수 선언과 값의 할당을 2개의 문으로 나누어 표현한 코드와 한줄로 표현한 코드는 정확히 동일하게 동작한다.
> 
```
즉, 자바스크립트 엔진은 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행한다.
```
- - -

 ❗❗
 
**변수 선언** 은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만,

**값의 할당** 은 런타임에 실행된다.
- - -

### 예제
```javascript
//(1)
console.log(score);        // undefined

var score = 80;            // 변수 선언, 값의 할당

//(2)
console.log(score);        // 80
```
1번 콘솔에서는 **런타임 이전 선언된** 변수 score에 **undefined**가 출력이 되고 런타임이 

순차적으로 돌며 score에 "80" 이라는 값이 할당 된 후 2번 콘솔에서 "80" 값이 출력되었다.

이때, **80이 할당될때 기존에 undefined가 있던 메모리에서 undefined를 지우는 것이 아니라 새로운 메모리에**

**저장되어 그 값을 출력한다.**

아래 그림으로 쉽게 이해하였다.

![image](https://user-images.githubusercontent.com/61656046/113137980-2f1ede80-9260-11eb-8c13-545c4f0970ca.png)

## 값의 재할당
```
값이 재할당 되어도 기존 메모리를 덮어쓰지 않고 새로운 메모리공간을 확보하고 그 공간에 새로운 값을 저장한다.
```


![image](https://user-images.githubusercontent.com/61656046/113138571-ee739500-9260-11eb-8c99-93cbb8b6462a.png)

### ❔ 그렇다면 이전 값들인 **undefined, 80** 는 어떻게 되느냐??

어떤 식별자와도 연결되어있지 않은 이 불필요한 값들은 **가비지 콜렉터**에 의해 자동 해제된다. 

단, 메모리에서 언제 해제될 지는 예측할 수 없다.

<br>


 ### 💬가비지 콜렉터
 ```
 가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다.
 
 더이상 사용되지 않는 메모리란 간단히 말하자면 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다.
 
 자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서 가비지 콜렉터를 통해 메모리누수(memory leak)를 방지한다.
 ```








